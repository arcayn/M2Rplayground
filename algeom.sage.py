

# This file was *autogenerated* from the file algeom.sage
from sage.all_cmdline import *   # import sage library

_sage_const_1 = Integer(1); _sage_const_2 = Integer(2); _sage_const_3 = Integer(3); _sage_const_15 = Integer(15); _sage_const_4318 = Integer(4318); _sage_const_0 = Integer(0)# this file will randomly generate polytopes and output them in plucker coordinate
# form

import random
import itertools


def plucker(P, vl=None):
    #M1 = Matrix([[1,1],[0,1]])
    if vl is None: vl = list(P.vertices())
    M_ = Matrix([b for b in vl]).transpose()
    M = M_.right_kernel().matrix()
    rows,_ = M.dimensions()
    minors = M.minors(rows)
    return ProjectiveSpace(len(minors) - _sage_const_1 , ZZ)(minors)

def gen_all_plucker(dim):
    assert dim in (_sage_const_2 , _sage_const_3 )
    for idx in range(_sage_const_15  if dim == _sage_const_2  else _sage_const_4318 ):
        pt = ReflexivePolytope(dim, idx)
        if pt.lattice().submodule(pt.vertices()).index_in(pt.lattice()) != _sage_const_1 :
            continue
        for vl in itertools.permutations(list(pt.vertices())):
            yield (plucker(pt, vl), idx)
    return

def gen_random_plucker_sample(dim):
    assert dim in (_sage_const_2 , _sage_const_3 )
    for idx in range(_sage_const_15  if dim == _sage_const_2  else _sage_const_4318 ):
        pt = ReflexivePolytope(dim, idx)
        if pt.lattice().submodule(pt.vertices()).index_in(pt.lattice()) != _sage_const_1 :
            continue
        yield pt
        #for vl in itertools.permutations(list(pt.vertices())):
        #    yield (plucker(pt, vl), idx)
    return

def map_lattice_pt(pt, M):
    V = [M * v for v in pt.vertices()]
    return LatticePolytope(V)

def gen_reflexive_polytope(dim):
    # will work on generating arbitrary reflexive polytopes
    # but for now we focus on generating isomorphisms to the PALP db
    assert dim in (_sage_const_2 , _sage_const_3 )

    idx = random.randint(_sage_const_0 , _sage_const_15  if dim == _sage_const_2  else _sage_const_4318 )
    base_pt = ReflexivePolytope(dim, idx)
    """
    transform = [random.randint(0, 100) for _ in range(dim + 1)]

    pt = base_pt
    for e,M in zip(transform, GL(dim, ZZ).as_matrix_group().gens()):
        pt = map_lattice_pt(pt, (M ^ e)) 
    """

    M = random_matrix(ZZ,dim,dim)
    while abs(M.det()) != _sage_const_1 :
        M = random_matrix(ZZ,dim,dim)
    pt = map_lattice_pt(base_pt, M)
    
    # make sure we have actually performed a CoB
    assert pt.index() == idx
    return pt, idx

def gen_primitive_polytope(dim, n):
    assert n >= dim + _sage_const_1 